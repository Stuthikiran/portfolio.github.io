<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DAA Lab Reflections</title>
</head>
<body>
    <h1>DAA Lab Reflections</h1>

    <h2>1. What are the Challenges in learning/understanding the above concepts?</h2>
    <ul>
        <li>
            <strong>Time Complexity Analysis:</strong>
            <ul>
                <li>Grasping how different algorithms scale with input size is challenging.</li>
                <li>Understanding logarithmic and exponential complexities can be confusing.</li>
                <li>Practical implementation requires familiarity with Big-O, Omega, and Theta notations.</li>
            </ul>
        </li>
        <li>
            <strong>Binary Search Tree (BST):</strong>
            <ul>
                <li>Comprehending tree balancing (like AVL or Red-Black Trees) can be difficult.</li>
                <li>Debugging operations like insertions and deletions while maintaining tree properties.</li>
            </ul>
        </li>
        <li>
            <strong>DFS and BFS:</strong>
            <ul>
                <li>Differentiating their practical use cases.</li>
                <li>Visualizing recursion in DFS and understanding its stack behavior.</li>
                <li>BFS implementation with queues can be non-intuitive.</li>
            </ul>
        </li>
        <li>
            <strong>Heap:</strong>
            <ul>
                <li>Understanding heap properties and maintaining them during insertions/deletions.</li>
                <li>Difficult to visualize the array representation of heaps.</li>
            </ul>
        </li>
        <li>
            <strong>Sorting Algorithms:</strong>
            <ul>
                <li>Choosing the appropriate sorting algorithm for different data types and sizes.</li>
                <li>Implementing complex algorithms like quicksort or merge sort.</li>
            </ul>
        </li>
        <li>
            <strong>Pattern Searching:</strong>
            <ul>
                <li>Understanding advanced algorithms like KMP or Boyer-Moore.</li>
                <li>Difficulties in building prefix/suffix tables for pattern matching.</li>
            </ul>
        </li>
        <li>
            <strong>Graph Algorithms:</strong>
            <ul>
                <li>Representing real-world problems as graphs.</li>
                <li>Understanding weighted and unweighted graphs and applying algorithms like Dijkstra or Floyd-Warshall.</li>
            </ul>
        </li>
    </ul>

    <h2>2. What are the Challenges in correlating with real-world applications?</h2>
    <ul>
        <li>
            <strong>Time Complexity Analysis:</strong>
            <ul>
                <li>Translating theoretical complexity into real-world performance due to system-level constraints like memory and CPU.</li>
            </ul>
        </li>
        <li>
            <strong>Binary Search Tree (BST):</strong>
            <ul>
                <li>Balancing trees in dynamic applications like search engines.</li>
                <li>Competing with other data structures (e.g., hash tables) in real-world scenarios.</li>
            </ul>
        </li>
        <li>
            <strong>DFS and BFS:</strong>
            <ul>
                <li>Selecting the correct traversal algorithm for tasks like pathfinding or maze solving.</li>
                <li>Adapting BFS for shortest path problems in weighted graphs.</li>
            </ul>
        </li>
        <li>
            <strong>Heap:</strong>
            <ul>
                <li>Using heaps effectively in applications like job scheduling and priority queues.</li>
            </ul>
        </li>
        <li>
            <strong>Sorting Algorithms:</strong>
            <ul>
                <li>Handling real-world constraints like external memory sorting for huge datasets.</li>
                <li>Optimizing for stability and in-place sorting in practical scenarios.</li>
            </ul>
        </li>
        <li>
            <strong>Pattern Searching:</strong>
            <ul>
                <li>Implementing search algorithms in text editors or plagiarism checkers with large datasets.</li>
            </ul>
        </li>
        <li>
            <strong>Graph Algorithms:</strong>
            <ul>
                <li>Applying algorithms in network routing, traffic management, or social networks.</li>
                <li>Scaling graph algorithms for large datasets like maps or web structures.</li>
            </ul>
        </li>
    </ul>

    <h2>3. How do you determine the most efficient approach/design techniques when solving a complex problem?</h2>
    <ul>
        <li>
            <strong>Time Complexity Analysis:</strong>
            <ul>
                <li>Analyze problem constraints and select algorithms with optimal time and space complexity.</li>
                <li>Example: Using divide-and-conquer strategies for efficient problem-solving.</li>
            </ul>
        </li>
        <li>
            <strong>Binary Search Tree (BST):</strong>
            <ul>
                <li>Use self-balancing trees for frequent insertions and deletions.</li>
                <li>Example: Employing AVL trees in applications requiring ordered data retrieval.</li>
            </ul>
        </li>
        <li>
            <strong>DFS and BFS:</strong>
            <ul>
                <li>Choose DFS for exhaustive searches and BFS for shortest paths.</li>
                <li>Example: DFS for maze-solving, BFS for social network analysis.</li>
            </ul>
        </li>
        <li>
            <strong>Heap:</strong>
            <ul>
                <li>Use heaps in priority-based applications.</li>
                <li>Example: Implementing priority queues for scheduling tasks.</li>
            </ul>
        </li>
        <li>
            <strong>Sorting Algorithms:</strong>
            <ul>
                <li>Match algorithm characteristics with problem constraints.</li>
                <li>Example: Using merge sort for large datasets and quicksort for small, in-memory data.</li>
            </ul>
        </li>
        <li>
            <strong>Pattern Searching:</strong>
            <ul>
                <li>Select algorithms based on text size and patterns.</li>
                <li>Example: Rabin-Karp for detecting plagiarism in documents.</li>
            </ul>
        </li>
        <li>
            <strong>Graph Algorithms:</strong>
            <ul>
                <li>Model the problem as a graph and choose appropriate traversal or pathfinding algorithms.</li>
                <li>Example: Dijkstra for route optimization in GPS applications.</li>
            </ul>
        </li>
    </ul>
</body>
</html>
